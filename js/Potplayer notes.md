* LeetCode1试细节
 * 运行时出现错误. time limit exceed 超时
 * 调试:  
* 3 函数
  * 访问一个所有外层作用域都没有的变量,那么最终会导致这个变量会被创建出来,而且是一个全局变量.而直接使用一个还没有在全局出现过的变量,
  * 对于任何一个变量的访问,都从代码中书写该变量的位置开始查找,逐级往上层作用域查找
  * let只针对变量的作用域,可见的作用域. 用let声明的变量只作用于离他最近的块级大括号
  * var 声明会提前 hoist(举起2)   var声明作用于离它最近的函数大括号
  * 闭包:函数每次作用都会创建作用域,
  * 函数本身处在哪个作用域 (A),它运行时创建的作用域 (B) 就在哪个作用域 (A) 内部
  * 函数本身也是处于一个作用域的,是创建它的函数运行时所创建的作用域
* 闭包: 闭包就是将函数内部和函数外部连接起来的一座桥梁 
 * 闭包:作用域嵌套
* 数组
 * 数组是值得有序集合
 * 数字定义
 * a.length 来获取数组的长度
 * [arr.length - 1] 来获取数组的最后一项
 * arr.length = 0 清空数组
 * arr.push() 向数组末尾添加一项或多项. 返回值: 添加后的数组长度. 原数组: 发生改变
 * arr.pop() 从右边删除元素  作用:删除数组末尾最后一项  原数组:发生改变. 返回值: 返回的是 删除的那一项
 * b.unshift 从前面添加元素. 向数组开头添加一项或多项. 返回值:添加后的数组长度. 原数组:发生改变

 * a.push 用于添加一个东西   在末尾添加一个东西
 * a.splice (1,2) 删除:  删除从第一个开始的2个元素
 * a.splice (1,0, 'world') 插入: 从第一个元素开始,添加一个元素world
 * a.splice (2,2 'world', false) 替换: 从第二个元素开始,替换两个,分别改为 world false
  <!-- slice 切片;片 -->
   <!-- var arr = ['a', 'b','c','d','e','f',];
   var res = arr.slice(1,3)
   console.log('返回值',res)  // ['b','c'] -->
 * slice(x): 从索引x处开始 一直克隆到末尾,将克隆的内容组成新数组返回
 * slice(x,y): 从索引x处克隆到索引y处 (不包含y项)
 * slice(-x): 从arr.length加上-处截取到数组末尾

 * indexOf() 
    var arr = [1,'a',2,'b',3,'c']
    var res = arr.indexOf('b')  // 3
    var res = arr.indexOf(20) // -1
  * 查找某个值 在数组中索引位置
  * 返回值: 查找到的那一项的索引
  * 如果查找不到 就返回 -1 说明数组中不存在这一项

 * b[5] 就是给第五项添加
 * b.shift 返回元素
 * C [] 创建一个数组
* 对列
 * 
 * arr.shift() 作用:删除数组开头的一项  原数组:发生改变  返回值:返回的是 删除的那一项 

* 递归: 一个调用自己的函数的行为叫做递归
* 递归:自己调用自己,设置终止条件,不要让
 * 结束条件
 * 认为这个已经正确实现了
 * 明确函数的功能: 接受什么参数,做什么事情,返回什么值
  * 认为这个以及正确实现了
  * 什么时候要返回值,什么时候不需要返回值
  * 执行操作而不求结果的,一般不需要返回值(排序)
  * 计算出一个结果的,往往需要返回值

  * 纯函数需要返回值
  * 非函数 (副作用函数) 不需要返回值 

# 数组
 * 可变性:
  * mutability (修改)  Immutable (不可变的)
  * 数据类型: 布尔值,数字, 
  * == 在判断对象的相等性时看的是是否是同一个对象,而判断基本数据类型时看其内容是否相同
  * 影射:影射就是一种从一个域到达另一个域的过程
  * 对象本身就是一个值,而对象本身又是其他值的集合
   * 对象变量,属性,值
     *  ?? 深度复制,复制, 浅复制?? 对象的指向问题
      * 
     * 映射?? 
     * 对映射的理解: 映射就是键值对的集合,但是
  * 键 key
  * 数组与对象的关系
   * ary.flat(): 展示
   * ary.keys 返回数组的小标

* 数据结果与算法分析
 * 算法分析:分析程序完成需要多少时间,和需要的空间问题
 * 把程序的运算时间减少,优化程序
* 时间复杂度与空间复杂度
 * 时间复杂度: 就是程序运行所需要的时间
  * 大 O 符号表示法
 * 一般法则:一次for循环的时间的运行时间至多是该for 循环内语句的运行时间乘以迭代的次数
* 空间复杂度: 执行的当前的函数所需要多少内存空间,就是空间复杂度
* 递归:当一个函数用它自己来定义时就称为递归
 * 定义的是用这个函数的本身

* 链表:基于JS语言
 * 线性同余
 * 数组倒叙,
 * 链表需要画图理解:链表图形化
 * 链表双指针
 * 冒泡: 
 * 排序: 
* UTF - 8:

# 高阶函数: 高阶函数就是把把一个函数作为参数
 * 函数本身所处一个作用域,函数可以被调用
  * 内层作用域代码(大括号的代码)声明的变量可以在外层得到
  * 内层可以访问到外层
   apply(调用, 应用)
  * fun = function() {}
  * fun.apply() 用特殊的形式允许源代码
    * fun.apply(null, [1,2,3])
     * fun(... [1,2,3])
    * fun.length  // 形参个数
    * fun.toString() //函数的源代码
    * fun.name  // 函数的名字
  * JSON: 所有属性名都必须用双引号括起来
   * JSON里面不能有实质运算,只能放数据直接量. 注释也不能有. 双引号的内部不能出现明文tab符,不能出现任意多余的符号,没有underfined
    * var jsonText = '[1,2,3,4,]' 4后面的逗号就是多余的符号  
     * 改为: var jsonText = '[1,2,3,4]'
  * reduce: 数组原生给的四个参数: reduce, ininialVal,ary[i], ary
   * ary是reduce的影藏参数
   * reduce通过函数的每次调用传递一个参数 
  * 函数组合: 高阶函数与普通函数和一个小的功能片段组合