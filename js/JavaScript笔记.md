# 24 JavaScript历史; 浏览器渲染机制;重绘与回流;白屏;FOUC;异步加载
 * 网页端的JavaScript
  * ECMAScript, DOM, BOM
	 * ECMAScript: 标准化的JavaScript,脱离宿主对象的JS语法, 也称为JavaScript核心,涉及如数据类型,数组,字符串,正则,对象等
	 * JS的运行宿主包括浏览器,服务器,桌面APP,移动端APP,命令行应用,小程序等
	 * DOM: 浏览器提供的一系列能操作网页结构的API	  (文档对象模型)
	 * BOM: 浏览器提供的一系列和页面结构无关但和浏览器其他功能相关的API  (浏览器对象模型)
 * 使用方法
  * 容器属性
	 * 1 声明使用grid布局: 
	  * display:grid;  /*inline-grid*/
	 * 2 画好虚拟表格:
	  * grid: 30px auto 30px / 10% 1fr 10%
		* grid-gap: 10px 20px;
	 * 3 告诉内容如何放置
	  * align-items: center;
		* justify-items: center;
		* align-content: start;
		* justify-content: space-evenly;
	* 子项属性
	 * 设置子项的范围和位置
	  * grid-column: 3 / span 2;
		* grid-row:3 / 4;
		* justify-self:start;
		* align-self:center;
 * 从URL输入到页面展示:
 * 浏览器的渲染机制:
  * 解析HTML标签,构建DOM树
  * 解析CSS,构建CSSOM树  (OM 对象模型)
  * 把DOM 和 CSSOM 组合成,渲染树(render tree)
  * 在渲染树的基础上进行布局,计算每个节点的几何结构
  * 把每个节点绘制到屏幕上(painting)
 * Repaint 和 Reflow
  * Reflow: (回流)
   * 重新计算元素的几何尺寸,位置
  * Repaint: (重新绘制)
   *  绘制界面发生变化的部分
 * Repaint 和 Reflow案例
  * 添加,删除,更新DOM节点(reflow, repaint)
  * 修改元素的margin,padding,border,(reflow, repaint)
  * display: none (reflow, repaint)
  * visibility: hidden (repaint)
  * 修改颜色,背景色( repaint)
 * 总结
  * 尽量一次修改样式
  * 给动画使用绝对定位可以减小reflow
  * DOM 离线后修改
 * 阻塞解析与阻塞渲染
  * 阻塞解析: 阻塞点后面的标签不会被解析，阻塞解析不一定阻塞其他外部资源的加载
  * 阻塞渲染:阻塞点后面的标签会继续被解析，img,link等会继续发送请求获取外部资源，但不会触发页面渲染（白屏），也不会执行JavaScript代码。
 * CSS加载
  * CSS 加载不阻塞解析,但会阻塞渲染
  * 白屏
   * 页面一片空白,突然显示完整的有样式的内容
   * 当link放在head标签,且加载时间久时,会出现白屏效果
  * FOUC
   * 页面一开始展示无样式的内容,突然样式正常
   * 当link放在页面底部,且加载时间久时,会出现FOUC 
  * Tips
   * 尽量把link放在head标签内,防止出现FOUC
# 25 变量;注释;数字类型
 * 变量
  * 内存能存储值的空间
  * 声明变量 
   * // var num = 1 声明一个变量,可选初始化一个值
   * // let str = 'hello'
    * 声明一个块级作用域变量, 可选初始化一个值
   * const isSelected = true
    * 声明一个只读的常量
   * 注意:
    * 变量需要先声明再使用
    * 全局使用域下var声明的变量是Windows的属性
   * 标识符规范
    * 变量的名字又叫标识符
     * 必须以字母,下划线_或者$开头
     * 后续的字符可以是数字 (0-9),字母,下划线,$
     * 区分大小写
     * 中文是合法的标识符,
     * 保留字不能作为标识符; 如 with super while function new null do...
  * 8种数据类型
   * 
    * 布尔值(Boolean), 有2个值分别是true和false
    * null 表示空, 注意不是Null 和 NULL
    * undefined, 表示变量未定义时的值
    * 数字(Number), 整数或者浮点数,比如100, 3.16. 数字大小是有限制的
    * 任意精度整数(Biglnt), 可以存储和操作大整数 100n
    * 字符串(String), 比如 "hello world", 'hello world'
    * Symbol, 创建一个独一无二的值 let key = Symbol()
   * 1种复合类型(complex type)
    * 除了上面7种以外的都是对象(Object), 比如 狭义的对象,函数,数组...
     * Object 的键均为String(字符串)类型,在Map里键可以是任意类型
     * 必须手动计算object的尺寸,但是可以很容易地获取使用Map的尺寸
     * Object有原型,所以映射中
    * 对象是多个 属性: 值 的集合
   * typeof
    * 使用typeof能
# 26 表达式与运算符
 * 表达式
  * 是一个值,或者说能计算得到一个值
  * 比如:
   * • 2 * (2 + 3) 
     • a + b
     • 3 > 2
     • a = 4  
 * 运算符
  * 用于连接表达式，组成一个复杂的表达式
   * 比如
    * • a * (2 + 3) 
      • a + b
      • 3 > 2
      • x = 'hello'
  * 加法运算符
  * 算术运算符
   * 加法运算符（Addition）：x + y
     减法运算符（Subtraction）： x - y
     乘法运算符（Multiplication）： x * y
     除法运算符（Division）：x / y
     余数运算符（Remainder）：x % y
     自增运算符（Increment）：++x 或者 x++
     自减运算符（Decrement）：--x 或者 x--
     求负运算符（Negate）：-x
     数值运算符（Convert to number）： +x
   * +xx : 这是一个表达式(一个结果),这个结果是x自增1后的值
   * x++ : 这是一个表达式(一个结果),这个结果是x的值,之后x自增1
  * 比较运算符:
   * === 严格相等
   * !== 严格不相等
   * < 小于
   * <= 小于或等于
   * > 大于
   * >= 大于或等于
  * 布尔值运算符
   * ! 取反运算符
   * && 且运算符
   * || 或运算符
   #### condition? case : false case 三元条件运算符
   * 前面写的是条件,后面写的是如果条件成立是一种结果,不成立又是另一种结果
  * 位运算符
 * 运算符结合性与优先级
  * 结合性
   * 从左到右 or 从右到左
    * a + b = 1 赋值是从右到左
    * 3 + 2 * 5 加法和乘法是从左到右
  * 优先级
   * 谁的优先级高先处理谁
* 27 流程控制语句
 * if
 * switch  (转换)
  * 语法
   * 进行比较的时候是===, 不发生类型转换
   * 思考并测试: 如果不加break,会有什么差别
 * while  (虽然;然而)
  * 语法: 先判断条件,在执行.  条件一直满足会一直执行
 * do-while  (语句;循环语句)
  * 语法: 先执行,在判断条件.  如果条件满足,在执行->在判断
 * for  (为了;循环)
  * 语法: (1)初始化; (2)判断条件; (3)条件改变
   * 先(1), 再(2)
   * 如果(2)为true,执行花括号内容;否则停止
   * 再(3), 再(2), 继续判断...
 * for-in
  * 语法: 遍历数组或者对象  输出数组的小标或者对象的属性
 * for-of
  * 语法: 遍历数组以及可遍历对象  输出每一项的值
 * break 关键字
  * 用于强制退出循环体: 遇到break, 循环立刻停止, 跳出循环体
 * continue 关键字: 用于强制退出本次循环:  遇到continue, 跳出本次循环, 继续下次循环
# 27 流程控制语句
 * if 
  * 注意: 条件会被强制转化成布尔值类型
 * switch
  * 进行比较时是 ===, 不发生类型转换
 * while
  * 先判断条件,再执行
  * 条件一直满足会一直执行
#  数组
 * 数组的ES5方法
  * Array,isArray(): 用来判断一个对象是不是数组
  * .indexOf(): 用来查找指定元素的位置,找不到返回-1
  * forEach():遍历数组,参数为回调函数,回调函数里的参数为
   * 遍历到的对应元素
   * 元素序号
   * 数组本身
  * every(): 所有回调函数都返回true的时候结果才会返回true,否则返回false
  * some(): 只要有一个回调函数都返回true的时候结果就返回true
  * .filter(): 过滤出满足条件的元素,构成新数组
  * map(): 遍历数组,回调函数返回值组成一个新的数组返回,新数组索引结构和原数组一致,原数组不变
  * reduce(): reduce(function(v1,v2), initValue)
   * 遍历数组,调回回调函数,将数组元素组成合成一个值
   * 初始值可选
    * 当出现参数是个数组,最终得到一个值这种场景,考虑使用reduce来简化代码
  
 * \ 的意思是转义
  * "c:\\ games\\war3\\" 的结果是 c:\games\war3\
  * \n 的意思是换行   `饥人谷\n培养有灵魂的工程师`
   * 的结果是: 饥人谷
   *          培养有灵魂的工程师
 * 字符串的写法: 可以使用 + 
  * 或者使用 \ 
  * `饥人谷`
  * 字符串模板
 * 数组是值的有序集合
 * 对象是值的具(有)名(字的 )集合
  * array 数组 index 下标
  * [0] 相对偏移量,没有定义
  * push 是返回数值数组完成后的
  * pop 是返回最后一个元素
# 28 
 * 递归:自己调用自己,一定要设置终止条件
  * 递归的缺点:多次重复计算,性能差
  * 递归的题目: 
   * 实现n的阶乘 fact(n) = n * fact(n - 1)
   * 5! 5*4! 4*3! 3*2! 2*1! 1
    * 如果输入的数是5的话,最后的结果就是5*4*3*2*1
     * 一直调用自己直到n等于1时,输出结果
      * function fact(n) {
       if (n === 1) {
         return 1
       }
       return n * fact(n - 1)
   }
   * 实现斐波那契数列   fib(n) = fib(n - 1) + fib(n - 2)
   * 1 1 2 3 5 8 13 21
    * function fib(n) {
      if (n === 1 || n === 2) {
        return 1
      }
      return fib(n - 1) + fib(n - 2)
    }
 * 递归的四条基本法则:
  * 基准情型: 必须总有某些基准情形,它无须递归就能解出
  * 不断推进: 对于那些需要递归求解的情形,每一次递归调用都必须要使求解状况朝接近基准情形的方向推进
  * 设计法则: 假设所有的递归调用都能运行
  * 合成效益法则(compound interest rule): 在求解一个问题的同一实例时,切勿在不同的递归调用中做重复性的工作
 * currying:柯里化

# 29 字符串,数组
 * 字符串的写法:双引号,单引号, ``符号
  * 对象:无序的数据集合,由若干个"值键对" (属性:值) 构成
   * {a: 10, b: 20}: 其中的a和b就是键, 10和20就是相应的值.而a的下标0就是 索引:下标,b的下标是1
  * 对象可以随时新增属性,随时更该属性值
  * 更多用法: Obeject.keys(obj)  // 属性变成数组
   * delete obj.name // 删除属性

 * 数组: 数组定义,
   * JSON: JavaScript对象表示法
  * JSON: 一种用于数据交换的文本格式, xxx.json
  * JSON里面不能有实质运算,只能放数据直接量. 注释也不能有. 双引号的内部不能出现明文tab符,不能出现任意多余的符号
   * 格式: 复合类型的值只能是数组或对象,不能是函数,正则表达式,对象,日期对象
    * 简单类型的值只有四种: 字符串,数值 (必须以十进制表示), 布尔值和null (不能使用NaN, Infinity, -Infinity 和underfined)
    * 字符串必须使用双引号表示,不能使用单引号
    * 对象的键名必须放在双引号里面
    * 数组或对象最后一个成员的后面,不能加逗号
  * JS内置对象
   * JSON.stringify: 用于把一个值变成符合JSON 格式的字符串
   ``` html
    let obj = {a: 1, b: 2}
    let str = JSON.stringify(obj)
    console.log(str)    // '{"a":1, "b": 2}'
    ```
   * JSON.parse: 用于把一个符号JSON格式的字符串还原对象
   ``` html
   let newObj = JSON.parse(str)
   console.log(newObj)   // {a: 1, b: 2}
   ```
  * JAVAscript 对象 vs.JSON
   * JaveScript 对象的字面量写法只是长的像
  * Date对象  (date: 日期)
   * 几种时间表示方式
    * GMT: 格林尼治
      UTC:原子秒长
      CST:北京时间
  * Math 与Number
   * Math: 
   * Number: 数字:
    * 数字的转换: parselnt(string,radix) 与parseFloat: 转换为整数或者浮点数
 * 高阶函数就是把把一个函数作为参数
 * 最常用的三种数组用法:
  * forEach(): 方法对数组的每个元素执行依次给定的函数
   * 求数组的和,
   * var a = [1, 4, 5, 77, 22, 97]
     var sum = 0
     a.forEach(item => sum = sum + item)  这个里面的数是一个参数,包含条件
     console.log(sum)
  * map(): 方法创建一个新数组,其结果是该数组中的每个元素是调用一次提供的函数后的返回
   * 给数组里的每一项加1
   * var a = [1, 4, 5, 77, 22, 97]
     const map1 = a.map(item => item + 1)
     console.log(map1)
  * filter():方法创建一个新数组,其包含通过所提供函数实现的测试的所有元素
   * 求这个函数的偶数项
    *  var a = [1, 4, 5, 77, 22, 97]
    const result = a.filter(item => item % 2 === 0)
    console.log(result)
# 30 引用类型 深浅拷贝
 * 基础类型与引用类型
  * 基础类型: 字符串,数字,布尔值,undefined和null
    * arr = [] : 本质上是创建一个新的空数组,让arr指向新的空数组
    * arr.length = 0 : 本质上是对原数组操作,让原数组变成空数组
  * 引用类型: 
 * 深拷贝与浅拷贝
  * 浅拷贝: 是创建一个新对象,这个对象有着原始对象属性的一份精确拷贝.如果属性是基本类型,拷贝的就是基本类型的值,如果属性是引用类型,拷贝的就是内存地址,所以如果其中一个对象改变了这个地址,就会影响到另一个对象
  * 深拷贝: 是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象
# 31 正则表达式
 * 正则表达式的作用: 用来匹配符合某种规则的字符串
  * 案例:
   * 检索字符串中符合某种规则多个字字符串
   * 判断用户的输入是否符合某种规则
   * 替换字符串中符合某种规则的文本
   * 用户的输入是不是合法的手机号
   * 用户的输入是不是合法的邮箱
   * 用户的输入是不是合法的用户名
 * 创建:字面量方式创建
  * 简单,直观,最常用
   * let reg = /+86\d{11}/g
 * 构建函数方式创建
  * 麻烦,但正则规则可通过字符串拼接,有些场景不得不用
   * let reg = new RegExp(' +86\d{11}', 'g')
    * 最后的g代表全局
    * g: global, 全文搜索,不添加的话搜索到第一个结果停止搜索
    * i: ingore case, 忽略大小写,默认大小写敏感
    * m: multiple linse, 多行搜索
 * 正则是为了防止用户误操作,不是越严格越好

* 对象,原型,原型链
 * 面向对象编程
  * 什么是对象: 把分散杂乱的个体和功能聚合成一个更大的独立体
 * 面向对象的逻辑:
 * 面向对象的逻辑:
  * 字面量创建32
  * 构造函数方式创建
  * class是语法糖
   

  

   





